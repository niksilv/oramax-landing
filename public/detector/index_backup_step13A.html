<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Orama X — Exoplanet Detector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <style>
    :root{ --card:#fff; --border:#e5e7eb; --muted:#666; }
    *{ box-sizing:border-box }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin: 24px; background:#fafafa; color:#111;}
    h1{ font-size:22px; margin-bottom:18px; }
    h3{ margin: 0 0 10px 0; font-size:16px;}
    .card { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:16px; margin-bottom:16px; box-shadow:0 4px 12px rgba(0,0,0,.04); }
    .row { display:flex; gap:16px; flex-wrap: wrap; }
    .col { flex:1; min-width: 360px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 8px 10px; border-bottom:1px solid #eee; text-align:left; font-size:13px;}
    th { background:#f7f7f7; font-weight:600;}
    .prob { font-weight:700; }
    input, select, button { padding:8px 10px; border:1px solid #ddd; border-radius:10px; font-size:13px; background:#fff;}
    input[type=text]{ min-width:260px; }
    button{ cursor:pointer; background:#111; color:#fff; border-color:#111;}
    button:disabled{ opacity:.7; cursor:not-allowed; }
    tr.clickable:hover{ background:#f7f7f7; cursor:pointer; }
    .muted{ color:var(--muted); font-size:12.5px; }
    .inline{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    summary{ cursor:pointer; }
    /* 13A highlighting */
    tr.vetted{ background:#eaffea !important; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #ddd; background:#fff;}
  </style>
</head>
<body>
  <h1>Orama X — Exoplanet Detector</h1>

  <div class="card">
    <h3>Live Fetch & Detect (select source)</h3>
    <div class="inline" style="margin-bottom:8px;">
      <label>Source</label>
      <select id="sourceSel">
        <option value="mast_spoc">MAST — SPOC (PDCSAP)</option>
        <option value="mast_qlp">MAST — QLP</option>
        <option value="url">External CSV/TXT URL</option>
      </select>

      <label>Mission</label>
      <select id="missionSel">
        <option value="auto">auto</option>
        <option value="TESS">TESS</option>
        <option value="Kepler">Kepler</option>
        <option value="K2">K2</option>
      </select>

      <!-- Βήμα 11: ασφαλείς παράμετροι -->
      <label>k-peaks</label>
      <input type="number" id="kpeaks" value="3" min="1" max="5" style="width:70px"/>

      <label>Detrend</label>
      <select id="detrendSel">
        <option value="flatten" selected>flatten</option>
        <option value="none">none</option>
      </select>

      <label><input type="checkbox" id="qualityChk" checked/> quality mask</label>
      <label><input type="checkbox" id="outlierChk" checked/> remove outliers</label>

      <label>σ</label>
      <input type="number" id="sigmaVal" value="5" step="0.5" style="width:70px"/>
    </div>

    <!-- Βήμα 13A: threshold slider -->
    <div class="inline" style="margin-bottom:8px;">
      <span class="badge">Planet threshold</span>
      <input type="range" id="thr" min="0.50" max="0.99" step="0.01" value="0.80" style="width:180px"/>
      <span class="muted">p ≥ <b id="thrLabel">0.80</b></span>
      <span class="muted" id="vetCount"></span>
    </div>

    <div class="inline">
      <input type="text" id="ticInput" list="targetList" placeholder='TIC 307210830 (for MAST)' />
      <datalist id="targetList"></datalist>

      <input type="text" id="urlInput" placeholder="https://.../lightcurve.csv (time,flux)" style="display:none; min-width:400px;" />
      <button id="runFetch">Fetch & Detect</button>
      <button id="exportCsv">Export CSV</button>
      <button id="exportVettedCsv" title="Export only candidates with P ≥ threshold">Export Vetted CSV</button>
      <span class="muted" id="status"></span>
    </div>
  </div>

  <details>
    <summary><b>Advanced: Upload custom light curve (TXT/CSV)</b></summary>
    <div class="card" style="margin-top:10px;">
      <h3>Upload TXT (2 columns: time, flux)</h3>
      <input type="file" id="file" accept=".txt,.csv"/>
      <button id="runUpload">Detect</button>
      <span class="muted" id="statusUp"></span>
    </div>
  </details>

  <div class="row">
    <div class="col card">
      <h3>Light Curve</h3>
      <div id="lc" style="height:380px;"></div>
    </div>
    <div class="col card">
      <h3>Phase-Folded (selected candidate)</h3>
      <div id="pf" style="height:380px;"></div>
    </div>
  </div>

  <div class="card">
    <h3>Candidates <span class="muted">(green = vetted with P ≥ threshold)</span></h3>
    <table id="cands"><thead>
      <tr>
        <th>#</th><th>Period (d)</th><th>Duration (d)</th><th>Depth</th><th>Power</th><th>P(planet)</th>
        <th>SNR</th><th>ΔBIC</th><th>Odd–Even Δ (ppm)</th><th>Secondary?</th>
      </tr>
    </thead><tbody></tbody></table>
  </div>

<script>
// ---- Helpers ----
function parseTxt(text){
  const lines = text.trim().split(/\r?\n/);
  const T=[], F=[];
  for(const line of lines){
    const [a,b] = line.trim().split(/[ ,\t]+/);
    if(!a || !b) continue;
    const t = parseFloat(a), f = parseFloat(b);
    if(Number.isFinite(t) && Number.isFinite(f)){ T.push(t); F.push(f); }
  }
  return [T,F];
}
function phaseFold(time, flux, period, t0){
  const folded = time.map((t,i)=>({x:(((t - t0 + 1e6*period)%period)/period), y:flux[i]}));
  folded.sort((a,b)=>a.x-b.x);
  return folded;
}
function shadedShapes(intervals){
  if(!intervals) return [];
  return intervals.map(iv => ({type:'rect', xref:'x', yref:'paper', x0:iv[0], x1:iv[1], y0:0, y1:1, fillcolor:'rgba(0,0,0,0.08)', line:{width:0}}));
}
function renderLC(T, F, intervals){
  Plotly.newPlot('lc',[{x:T, y:F, mode:'markers', marker:{size:3}}], {margin:{t:10}, shapes: shadedShapes(intervals)});
}
function renderPF(T, F, cand){
  if(!cand) { Plotly.purge('pf'); return; }
  const folded = phaseFold(T, F, cand.period, cand.t0);
  Plotly.newPlot('pf',[{x:folded.map(d=>d.x), y:folded.map(d=>d.y), mode:'markers', marker:{size:3}}], {xaxis:{title:'Phase [0,1)'}, margin:{t:10}});
}

// ---- State ----
let lcTime=[], lcFlux=[], lastCands=[], currentTarget='(Uploaded TXT)';

// ---- Threshold helpers ----
function getThreshold(){
  const v = Number(document.getElementById('thr').value || 0.8);
  return Math.min(0.99, Math.max(0.5, v));
}
function setThrLabel(){
  const thr = getThreshold();
  document.getElementById('thrLabel').textContent = thr.toFixed(2);
}
function updateVetCount(){
  const thr = getThreshold();
  const k = (lastCands||[]).filter(c=> (c?.probability ?? 0) >= thr).length;
  const n = (lastCands||[]).length;
  document.getElementById('vetCount').textContent = n ? `— vetted: ${k}/${n}` : '';
}

// ---- Table rendering (with highlighting) ----
function renderTable(candidates){
  const tbody = document.querySelector('#cands tbody'); tbody.innerHTML='';
  const thr = getThreshold();
  candidates.forEach((c, i)=>{
    const tr = document.createElement('tr'); tr.className = 'clickable'; tr.dataset.idx = i;
    if ((c?.probability ?? 0) >= thr) tr.classList.add('vetted');
    const snr  = (c.fit && Number.isFinite(c.fit.snr)) ? c.fit.snr.toFixed(1) : '';
    const dbic = (c.fit && Number.isFinite(c.fit.delta_bic)) ? c.fit.delta_bic.toFixed(1) : '';
    tr.innerHTML = `<td>${i+1}</td><td>${c.period.toFixed(6)}</td><td>${c.duration.toFixed(6)}</td>
                    <td>${(+c.depth).toExponential(2)}</td><td>${c.power.toFixed(3)}</td>
                    <td class='prob'>${(100*c.probability).toFixed(1)}%</td>
                    <td>${snr}</td><td>${dbic}</td>
                    <td>${Math.round(c.vetting.odd_even_diff_ppm)}</td>
                    <td>${c.vetting.has_secondary_like ? 'Yes' : 'No'}</td>`;
    tr.onclick = ()=> selectCandidate(i);
    tbody.appendChild(tr);
  });
  updateVetCount();
}
function selectCandidate(i){
  const cand = lastCands[i];
  renderPF(lcTime, lcFlux, cand);
  renderLC(lcTime, lcFlux, cand.windows ? cand.windows.intervals : []);
}
function renderAll(T, F, candidates){
  lcTime=T; lcFlux=F; lastCands=candidates||[];
  renderLC(T,F, lastCands[0]?.windows?.intervals || []);
  renderPF(T,F, lastCands[0]);
  renderTable(lastCands);
}

// ---- Source toggle ----
function toggleInputs(){
  const src = document.getElementById('sourceSel').value;
  document.getElementById('ticInput').style.display = (src==='url')?'none':'inline-block';
  document.getElementById('urlInput').style.display = (src==='url')?'inline-block':'none';
}
document.getElementById('sourceSel').addEventListener('change', toggleInputs);
toggleInputs();

// ---- Fetch & Detect ----
async function runFetch(){
  const status = document.getElementById('status');
  try{
    status.textContent = 'Fetching...';
    const source = document.getElementById('sourceSel').value;
    const mission = document.getElementById('missionSel').value;
    const target = document.getElementById('ticInput').value.trim();
    const url    = document.getElementById('urlInput').value.trim();

    const kpeaks = Number(document.getElementById('kpeaks').value || 3);
    const detrend = document.getElementById('detrendSel').value;
    const quality = document.getElementById('qualityChk').checked;
    const remove_outliers = document.getElementById('outlierChk').checked;
    const sigma = Number(document.getElementById('sigmaVal').value || 5);

    const body = JSON.stringify({ source, mission, target, url, kpeaks, detrend, quality, remove_outliers, sigma });
    const res = await fetch('api/fetch_detect', { method:'POST', headers:{'Content-Type':'application/json'}, body });
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget = data.target || target || url;
    renderAll(data.time, data.flux, data.candidates);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}
document.getElementById('runFetch').addEventListener('click', runFetch);

// ---- Upload TXT (Advanced) ----
async function runUpload(){
  const status = document.getElementById('statusUp');
  try{
    status.textContent = 'Running...';
    const file = document.getElementById('file').files[0];
    if(!file){ alert('Choose a .txt or .csv first'); status.textContent=''; return; }
    const txt = await file.text();
    const [T,F] = parseTxt(txt);
    const form = new FormData(); form.append('file', new Blob([txt], {type:'text/plain'}), 'lc.txt');
    const res = await fetch('api/detect?kpeaks=3', {method:'POST', body: form});
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget='(Uploaded TXT)';
    renderAll(T,F,data.candidates);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}
document.getElementById('runUpload').addEventListener('click', runUpload);

// ---- Export CSVs ----
function buildCsvRows(cands){
  const rows = [];
  rows.push(["target","idx","period_d","duration_d","depth","power","P_planet","SNR","delta_BIC","odd_even_ppm","secondary_ppm","has_secondary","midtimes_sample"]);
  cands.forEach((c,i)=>{
    const mids = (c.windows?.midtimes||[]).slice(0,5).join("|");
    rows.push([currentTarget, i+1, c.period, c.duration, c.depth, c.power, c.probability,
               (c.fit?.snr ?? ""), (c.fit?.delta_bic ?? ""),
               Math.round(c.vetting.odd_even_diff_ppm), Math.round(c.vetting.secondary_depth_ppm),
               c.vetting.has_secondary_like, mids]);
  });
  return rows;
}
document.getElementById('exportCsv').addEventListener('click', ()=>{
  if(!lastCands.length){ alert("Run Detect first."); return; }
  const rows = buildCsvRows(lastCands);
  const csv = rows.map(r=>r.join(",")).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv"}));
  a.download = `oramax_candidates_${(currentTarget||'target').toString().replace(/\s+/g,'_')}.csv`;
  a.click();
});
document.getElementById('exportVettedCsv').addEventListener('click', ()=>{
  if(!lastCands.length){ alert("Run Detect first."); return; }
  const thr = getThreshold();
  const vetted = lastCands.filter(c => (c?.probability ?? 0) >= thr);
  if(!vetted.length){ alert(`No candidates with P ≥ ${thr.toFixed(2)}`); return; }
  const rows = buildCsvRows(vetted);
  rows.unshift(["threshold", thr]); // metadata line
  const csv = rows.map(r=>r.join(",")).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv"}));
  a.download = `oramax_vetted_${(currentTarget||'target').toString().replace(/\s+/g,'_')}_p${thr.toFixed(2)}.csv`;
  a.click();
});

// ---- Threshold UI events ----
document.getElementById('thr').addEventListener('input', ()=>{
  setThrLabel();
  renderTable(lastCands||[]);
});
setThrLabel();

// ---- Autocomplete (ΠΑΡΑΜΕΝΕΙ όπως στο Βήμα 10) ----
function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
const updateSuggest = debounce(async ()=>{
  const src = document.getElementById('sourceSel').value;
  const mission = document.getElementById('missionSel').value;
  const input = document.getElementById('ticInput');
  const q = input.value.trim();
  const dl = document.getElementById('targetList');
  if (src==='url' || q.length < 3){ dl.innerHTML=''; return; }
  const dom = (mission==='Kepler') ? 'Kepler' : (mission==='TESS' ? 'TESS' : 'all');
  try{
    const r = await fetch(`api/suggest?q=${encodeURIComponent(q)}&domain=${dom}&limit=10`);
    const data = await r.json();
    dl.innerHTML = '';
    (data.items||[]).forEach(item=>{
      const opt = document.createElement('option');
      opt.value = item.value;
      opt.label = item.label;
      dl.appendChild(opt);
    });
  }catch(e){ /* silent */ }
}, 400);
document.getElementById('ticInput').addEventListener('input', updateSuggest);
</script>
</body>
</html>

