<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Orama X — Exoplanet Detector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <style>
    :root{ --card:#fff; --border:#e5e7eb; --muted:#666; }
    *{ box-sizing:border-box }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin: 24px; background:#fafafa; color:#111;}
    h1{ font-size:22px; margin-bottom:18px; }
    h3{ margin: 0 0 10px 0; font-size:16px;}
    .card { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:16px; margin-bottom:16px; box-shadow:0 4px 12px rgba(0,0,0,.04); }
    .row { display:flex; gap:16px; flex-wrap: wrap; }
    .col { flex:1; min-width: 360px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 8px 10px; border-bottom:1px solid #eee; text-align:left; font-size:13px;}
    th { background:#f7f7f7; font-weight:600;}
    .prob { font-weight:700; }
    input, select, button { padding:8px 10px; border:1px solid #ddd; border-radius:10px; font-size:13px; background:#fff;}
    input[type=text]{ min-width:260px; }
    button{ cursor:pointer; background:#111; color:#fff; border-color:#111;}
    button:disabled{ opacity:.7; cursor:not-allowed; }
    tr.clickable:hover{ background:#f7f7f7; cursor:pointer; }
    .muted{ color:var(--muted); font-size:12.5px; }
    .inline{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    summary{ cursor:pointer; }
    tr.vetted{ background:#eaffea !important; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #ddd; background:#fff;}
    .badge-ok{ background:#e6ffed; border-color:#b3ffcc; color:#006622; }
    .badge-beb{ background:#ffe6e6; border-color:#ffb3b3; color:#b30000; }
    .note{ font-size:12.5px; color:#333; }
  </style>
</head>
<body>
  <h1>Orama X — Exoplanet Detector</h1>

  <div class="card">
    <h3>Live Fetch & Detect (select source)</h3>
    <div class="inline" style="margin-bottom:8px;">
      <label>Source</label>
      <select id="sourceSel">
        <option value="mast_spoc">MAST — SPOC (PDCSAP)</option>
        <option value="mast_qlp">MAST — QLP</option>
        <option value="url">External CSV/TXT URL</option>
      </select>

      <label>Mission</label>
      <select id="missionSel">
        <option value="auto">auto</option>
        <option value="TESS">TESS</option>
        <option value="Kepler">Kepler</option>
        <option value="K2">K2</option>
      </select>

      <label>k-peaks</label>
      <input type="number" id="kpeaks" value="3" min="1" max="5" style="width:70px"/>

      <label>Detrend</label>
      <select id="detrendSel">
        <option value="flatten" selected>flatten</option>
        <option value="none">none</option>
      </select>

      <label><input type="checkbox" id="qualityChk" checked/> quality mask</label>
      <label><input type="checkbox" id="outlierChk" checked/> remove outliers</label>

      <label>σ</label>
      <input type="number" id="sigmaVal" value="5" step="0.5" style="width:70px"/>

      <label><input type="checkbox" id="centroidChk"/> Centroid vetting (TESSCut)</label>
      <label><input type="checkbox" id="gaiaChk"/> Gaia neighbors</label>
    </div>

    <!-- Probability threshold -->
    <div class="inline" style="margin-bottom:8px;">
      <span class="badge">Planet threshold</span>
      <input type="range" id="thr" min="0.50" max="0.99" step="0.01" value="0.80" style="width:180px"/>
      <span class="muted">p ≥ <b id="thrLabel">0.80</b></span>
      <span class="muted" id="vetCount"></span>
    </div>

    <!-- Centroid thresholds -->
    <div class="inline" style="margin-bottom:8px;">
      <span class="badge">Centroid σ-thr</span>
      <input type="range" id="sigmaThr" min="1" max="10" step="0.5" value="3" style="width:160px"/>
      <span class="muted"><b id="sigmaThrLabel">3.0</b></span>

      <span class="badge">ρ-thr</span>
      <input type="range" id="rhoThr" min="0.00" max="0.50" step="0.01" value="0.15" style="width:160px"/>
      <span class="muted"><b id="rhoThrLabel">0.15</b></span>

      <span class="badge">Gaia radius ["]</span>
      <input type="range" id="neiRadius" min="20" max="120" step="5" value="60" style="width:160px"/>
      <span class="muted"><b id="neiRadiusLabel">60</b></span>
    </div>

    <div class="inline">
      <input type="text" id="ticInput" list="targetList" placeholder='TIC 307210830 (for MAST)' />
      <datalist id="targetList"></datalist>

      <input type="text" id="urlInput" placeholder="https://.../lightcurve.csv (time,flux)" style="display:none; min-width:400px;" />
      <button id="runFetch">Fetch & Detect</button>
      <button id="exportCsv">Export CSV</button>
      <button id="exportVettedCsv" title="Export only candidates with P ≥ threshold">Export Vetted CSV</button>
      <span class="muted" id="status"></span>
    </div>

    <div class="note">
      Tip: το Centroid vetting κατεβάζει TESSCut cutout (TESS) και μπορεί να πάρει μερικά δευτερόλεπτα. Το Gaia neighbors απαιτεί TIC lookup.
    </div>
  </div>

  <details>
    <summary><b>Advanced: Upload custom light curve (TXT/CSV)</b></summary>
    <div class="card" style="margin-top:10px;">
      <h3>Upload TXT (2 columns: time, flux)</h3>
      <input type="file" id="file" accept=".txt,.csv"/>
      <button id="runUpload">Detect</button>
      <span class="muted" id="statusUp"></span>
    </div>
  </details>

  <div class="row">
    <div class="col card">
      <h3>Light Curve</h3>
      <div id="lc" style="height:380px;"></div>
    </div>
    <div class="col card">
      <h3>Phase-Folded (selected candidate)</h3>
      <div id="pf" style="height:340px;"></div>
      <div id="centroidBox" class="muted" style="margin-top:8px;"></div>
    </div>
  </div>

  <div class="card">
    <h3>Candidates <span class="muted">(green = vetted with P ≥ threshold; badge = centroid test)</span></h3>
    <table id="cands"><thead>
      <tr>
        <th>#</th><th>Period (d)</th><th>Duration (d)</th><th>Depth</th><th>Power</th><th>P(planet)</th>
        <th>SNR</th><th>ΔBIC</th><th>Odd–Even Δ (ppm)</th><th>Secondary?</th><th>Centroid</th>
      </tr>
    </thead><tbody></tbody></table>
  </div>

  <div class="card">
    <h3>Neighbors (Gaia DR3)</h3>
    <div id="neighborsPlot" style="height:320px;"></div>
    <div class="muted" id="neighborsInfo"></div>
    <table id="neighborsTbl" style="margin-top:8px;"><thead>
      <tr><th>sep ["]</th><th>Gmag</th><th>BP−RP</th></tr>
    </thead><tbody></tbody></table>
  </div>

<script>
// ---------- Helpers ----------
function parseTxt(text){
  const lines = text.trim().split(/\r?\n/);
  const T=[], F=[];
  for(const line of lines){
    const [a,b] = line.trim().split(/[ ,\t]+/);
    if(!a || !b) continue;
    const t = parseFloat(a), f = parseFloat(b);
    if(Number.isFinite(t) && Number.isFinite(f)){ T.push(t); F.push(f); }
  }
  return [T,F];
}
function phaseFold(time, flux, period, t0){
  const folded = time.map((t,i)=>({x:(((t - t0 + 1e6*period)%period)/period), y:flux[i]}));
  folded.sort((a,b)=>a.x-b.x);
  return folded;
}
function shadedShapes(intervals){
  if(!intervals) return [];
  return intervals.map(iv => ({type:'rect', xref:'x', yref:'paper', x0:iv[0], x1:iv[1], y0:0, y1:1, fillcolor:'rgba(0,0,0,0.08)', line:{width:0}}));
}
function renderLC(T, F, intervals){
  Plotly.newPlot('lc',[{x:T, y:F, mode:'markers', marker:{size:3}}], {margin:{t:10}, shapes: shadedShapes(intervals)});
}
function renderPF(T, F, cand){
  if(!cand) { Plotly.purge('pf'); return; }
  const folded = phaseFold(T, F, cand.period, cand.t0);
  Plotly.newPlot('pf',[{x:folded.map(d=>d.x), y:folded.map(d=>d.y), mode:'markers', marker:{size:3}}], {xaxis:{title:'Phase [0,1)'}, margin:{t:10}});
}
function centroidBadge(cent, sigmaThr, rhoThr){
  if(!cent || !cent.available) return '';
  const sig = cent.sigma, rho = cent.rho_flux_centroid;
  const beb = (Number.isFinite(sig) && sig >= sigmaThr) && (!Number.isFinite(rho) || rho >= rhoThr);
  return beb ? '<span class="badge badge-beb">BEB</span>' : '<span class="badge badge-ok">OK</span>';
}
function renderCentroidInfo(cent, sigmaThr, rhoThr){
  const el = document.getElementById('centroidBox');
  if(!cent){ el.textContent = ''; return; }
  if(!cent.available){
    el.textContent = `Centroid: ${cent.reason || 'n/a'}`;
    return;
  }
  const parts = [];
  if (Number.isFinite(cent.dr_pix))  parts.push(`Δr = ${cent.dr_pix.toFixed(3)} px`);
  if (Number.isFinite(cent.sigma))   parts.push(`σ = ${cent.sigma.toFixed(2)} (thr ${sigmaThr.toFixed(2)})`);
  if (Number.isFinite(cent.rho_flux_centroid)) parts.push(`ρ = ${cent.rho_flux_centroid.toFixed(2)} (thr ${rhoThr.toFixed(2)})`);
  const txt = parts.join(', ');
  const badge = centroidBadge(cent, sigmaThr, rhoThr);
  el.innerHTML = `Centroid: ${txt} ${badge ? ' — ' + badge : ''}`;
}
function renderNeighbors(nei){
  const info = document.getElementById('neighborsInfo');
  const tbl = document.querySelector('#neighborsTbl tbody');
  const plot = document.getElementById('neighborsPlot');
  if(!nei || !nei.available){
    info.textContent = nei?.reason ? ('Gaia: ' + nei.reason) : 'Gaia: n/a';
    tbl.innerHTML=''; Plotly.purge('neighborsPlot'); return;
  }
  const items = nei.items || [];
  const rad = Number(nei.radius_arcsec || 60);
  info.textContent = `radius ${rad}" — ${items.length} sources (circle = 21" TESS pixel)`;
  tbl.innerHTML = '';
  items.slice(0,80).forEach(r=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r.sep_arcsec.toFixed(1)}</td><td>${(r.Gmag??'').toString()}</td><td>${(Number.isFinite(r.BP_RP)?r.BP_RP.toFixed(2):'')}</td>`;
    tbl.appendChild(tr);
  });
  const x = items.map(r=>r.dx_arcsec), y = items.map(r=>r.dy_arcsec), s = items.map(r=>Math.max(6, 12 - 0.8*((r.Gmag??15)-10)));
  Plotly.newPlot('neighborsPlot',[
    {x:[0], y:[0], mode:'markers+text', text:['target'], textposition:'top center', marker:{size:10, symbol:'x'}},
    {x:x, y:y, mode:'markers', marker:{size:s}}
  ],{
    margin:{t:10}, xaxis:{title:'East ["]'}, yaxis:{title:'North ["]', scaleanchor:'x', scaleratio:1},
    shapes:[
      {type:'circle',xref:'x',yref:'y',x0:-21,y0:-21,x1:21,y1:21, line:{dash:'dot'}},
      {type:'circle',xref:'x',yref:'y',x0:-rad,y0:-rad,x1:rad,y1:rad, line:{dash:'solid'}}
    ]
  });
}

// ---------- State ----------
let lcTime=[], lcFlux=[], lastCands=[], currentTarget='(Uploaded TXT)';

// ---------- Threshold helpers ----------
function getThreshold(){ return Math.min(0.99, Math.max(0.5, Number(document.getElementById('thr').value || 0.8))); }
function setThrLabel(){ document.getElementById('thrLabel').textContent = getThreshold().toFixed(2); }
function getSigmaThr(){ return Number(document.getElementById('sigmaThr').value || 3.0); }
function getRhoThr(){   return Number(document.getElementById('rhoThr').value   || 0.15); }
function setCentroidThrLabels(){
  document.getElementById('sigmaThrLabel').textContent = getSigmaThr().toFixed(2);
  document.getElementById('rhoThrLabel').textContent = getRhoThr().toFixed(2);
}
function getNeighborsFlag(){ return document.getElementById('gaiaChk').checked; }
function getNeighborsRadius(){ return Number(document.getElementById('neiRadius').value || 60); }
function setNeighborsLabel(){ document.getElementById('neiRadiusLabel').textContent = getNeighborsRadius(); }
function updateVetCount(){
  const thr = getThreshold();
  const k = (lastCands||[]).filter(c=> (c?.probability ?? 0) >= thr).length;
  const n = (lastCands||[]).length;
  document.getElementById('vetCount').textContent = n ? `— vetted: ${k}/${n}` : '';
}

// ---------- Table rendering ----------
function renderTable(candidates){
  const tbody = document.querySelector('#cands tbody'); tbody.innerHTML='';
  const thr = getThreshold(), sThr = getSigmaThr(), rThr = getRhoThr();
  candidates.forEach((c, i)=>{
    const tr = document.createElement('tr'); tr.className = 'clickable'; tr.dataset.idx = i;
    if ((c?.probability ?? 0) >= thr) tr.classList.add('vetted');
    const snr  = (c.fit && Number.isFinite(c.fit.snr)) ? c.fit.snr.toFixed(1) : '';
    const dbic = (c.fit && Number.isFinite(c.fit.delta_bic)) ? c.fit.delta_bic.toFixed(1) : '';
    const badge = centroidBadge(c.centroid, sThr, rThr);
    tr.innerHTML = `<td>${i+1}</td><td>${c.period.toFixed(6)}</td><td>${c.duration.toFixed(6)}</td>
                    <td>${(+c.depth).toExponential(2)}</td><td>${c.power.toFixed(3)}</td>
                    <td class='prob'>${(100*c.probability).toFixed(1)}%</td>
                    <td>${snr}</td><td>${dbic}</td>
                    <td>${Math.round(c.vetting.odd_even_diff_ppm)}</td>
                    <td>${c.vetting.has_secondary_like ? 'Yes' : 'No'}</td>
                    <td>${badge}</td>`;
    tr.onclick = ()=> selectCandidate(i);
    tbody.appendChild(tr);
  });
  updateVetCount();
}
function selectCandidate(i){
  const cand = lastCands[i];
  renderPF(lcTime, lcFlux, cand);
  renderLC(lcTime, lcFlux, cand.windows ? cand.windows.intervals : []);
  renderCentroidInfo(cand.centroid, getSigmaThr(), getRhoThr());
}
function renderAll(T, F, candidates, neighbors){
  lcTime=T; lcFlux=F; lastCands=candidates||[];
  renderLC(T,F, lastCands[0]?.windows?.intervals || []);
  renderPF(T,F, lastCands[0]);
  renderCentroidInfo(lastCands[0]?.centroid, getSigmaThr(), getRhoThr());
  renderTable(lastCands);
  renderNeighbors(neighbors);
}

// ---------- Source toggle ----------
function toggleInputs(){
  const src = document.getElementById('sourceSel').value;
  document.getElementById('ticInput').style.display = (src==='url')?'none':'inline-block';
  document.getElementById('urlInput').style.display = (src==='url')?'inline-block':'none';
}

// ---------- Fetch & Detect ----------
async function runFetch(){
  const status = document.getElementById('status');
  try{
    status.textContent = 'Fetching...';
    const source = document.getElementById('sourceSel').value;
    const mission = document.getElementById('missionSel').value;
    const target = document.getElementById('ticInput').value.trim();
    const url    = document.getElementById('urlInput').value.trim();

    const kpeaks = Number(document.getElementById('kpeaks').value || 3);
    const detrend = document.getElementById('detrendSel').value;
    const quality = document.getElementById('qualityChk').checked;
    const remove_outliers = document.getElementById('outlierChk').checked;
    const sigma = Number(document.getElementById('sigmaVal').value || 5);
    const centroid = document.getElementById('centroidChk').checked;

    const neighbors = getNeighborsFlag();
    const neighbors_radius = getNeighborsRadius();

    const body = JSON.stringify({ source, mission, target, url, kpeaks, detrend, quality, remove_outliers, sigma, centroid, neighbors, neighbors_radius });
    const res = await fetch('api/fetch_detect', { method:'POST', headers:{'Content-Type':'application/json'}, body });
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget = data.target || target || url;
    renderAll(data.time, data.flux, data.candidates, data.neighbors);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}

// ---------- Upload TXT ----------
async function runUpload(){
  const status = document.getElementById('statusUp');
  try{
    status.textContent = 'Running...';
    const file = document.getElementById('file').files[0];
    if(!file){ alert('Choose a .txt or .csv first'); status.textContent=''; return; }
    const txt = await file.text();
    const [T,F] = parseTxt(txt);
    const form = new FormData(); form.append('file', new Blob([txt], {type:'text/plain'}), 'lc.txt');
    const res = await fetch('api/detect?kpeaks=3', {method:'POST', body: form});
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget='(Uploaded TXT)';
    renderAll(T,F,data.candidates, null);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}

// ---------- Export CSVs ----------
function buildCsvRows(cands){
  const rows = [];
  rows.push(["target","idx","period_d","duration_d","depth","power","P_planet","SNR","delta_BIC","odd_even_ppm","secondary_ppm","has_secondary","midtimes_sample","centroid_dr_pix","centroid_sigma","centroid_rho","centroid_suspect_beb"]);
  cands.forEach((c,i)=>{
    const mids = (c.windows?.midtimes||[]).slice(0,5).join("|");
    const cent = c.centroid || {};
    rows.push([currentTarget, i+1, c.period, c.duration, c.depth, c.power, c.probability,
               (c.fit?.snr ?? ""), (c.fit?.delta_bic ?? ""),
               Math.round(c.vetting.odd_even_diff_ppm), Math.round(c.vetting.secondary_depth_ppm),
               c.vetting.has_secondary_like, mids,
               (cent.dr_pix ?? ""), (cent.sigma ?? ""), (cent.rho_flux_centroid ?? ""), (cent.suspect_beb ?? "")]);
  });
  return rows;
}
function exportCsv(rows, name){
  const csv = rows.map(r=>r.join(",")).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv"}));
  a.download = name; a.click();
}

// ---------- Autocomplete ----------
function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
const updateSuggest = debounce(async ()=>{
  const src = document.getElementById('sourceSel').value;
  const mission = document.getElementById('missionSel').value;
  const input = document.getElementById('ticInput');
  const q = input.value.trim();
  const dl = document.getElementById('targetList');
  if (src==='url' || q.length < 3){ dl.innerHTML=''; return; }
  const dom = (mission==='Kepler') ? 'Kepler' : (mission==='TESS' ? 'TESS' : 'all');
  try{
    const r = await fetch(`api/suggest?q=${encodeURIComponent(q)}&domain=${dom}&limit=10`);
    const data = await r.json();
    dl.innerHTML = '';
    (data.items||[]).forEach(item=>{
      const opt = document.createElement('option');
      opt.value = item.value;
      opt.label = item.label;
      dl.appendChild(opt);
    });
  }catch(e){ /* silent */ }
}, 400);

// ---------- Wire-up (once DOM is ready) ----------
document.addEventListener('DOMContentLoaded', ()=>{
  // init labels
  setThrLabel(); setCentroidThrLabels(); setNeighborsLabel();
  // toggle inputs
  toggleInputs();

  // event bindings
  document.getElementById('sourceSel').addEventListener('change', toggleInputs);
  document.getElementById('ticInput').addEventListener('input', updateSuggest);

  document.getElementById('runFetch').addEventListener('click', runFetch);
  document.getElementById('runUpload').addEventListener('click', runUpload);

  document.getElementById('exportCsv').addEventListener('click', ()=>{
    if(!lastCands.length){ alert("Run Detect first."); return; }
    exportCsv(buildCsvRows(lastCands), `oramax_candidates_${(currentTarget||'target').toString().replace(/\s+/g,'_')}.csv`);
  });
  document.getElementById('exportVettedCsv').addEventListener('click', ()=>{
    if(!lastCands.length){ alert("Run Detect first."); return; }
    const thr = getThreshold();
    const vetted = lastCands.filter(c => (c?.probability ?? 0) >= thr);
    if(!vetted.length){ alert(`No candidates with P ≥ ${thr.toFixed(2)}`); return; }
    const rows = buildCsvRows(vetted);
    rows.unshift(["threshold", thr]);
    exportCsv(rows, `oramax_vetted_${(currentTarget||'target').toString().replace(/\s+/g,'_')}_p${thr.toFixed(2)}.csv`);
  });

  document.getElementById('thr').addEventListener('input', ()=>{ setThrLabel(); renderTable(lastCands||[]); });
  document.getElementById('sigmaThr').addEventListener('input', ()=>{ setCentroidThrLabels(); renderTable(lastCands||[]); renderCentroidInfo(lastCands[0]?.centroid, getSigmaThr(), getRhoThr()); });
  document.getElementById('rhoThr').addEventListener('input', ()=>{ setCentroidThrLabels(); renderTable(lastCands||[]); renderCentroidInfo(lastCands[0]?.centroid, getSigmaThr(), getRhoThr()); });
  document.getElementById('neiRadius').addEventListener('input', ()=>{ setNeighborsLabel(); });
});
</script>
</body>
</html>