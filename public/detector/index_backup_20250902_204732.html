<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Orama X · Exoplanet Detector</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
  <style>
    :root{ --card:#fff; --border:#e5e7eb; --muted:#666; }
    *{ box-sizing:border-box }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin: 24px; background:#fafafa; color:#111;}
    h1{ font-size:22px; margin-bottom:18px; }
    h3{ margin: 0 0 10px 0; font-size:16px;}
    .card { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:16px; margin-bottom:16px; box-shadow:0 4px 12px rgba(0,0,0,.04); }
    .row { display:flex; gap:16px; flex-wrap: wrap; }
    .col { flex:1; min-width: 360px; }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 8px 10px; border-bottom:1px solid #eee; text-align:left; font-size:13px;}
    th { background:#f7f7f7; font-weight:600;}
    .prob { font-weight:700; }
    input, select, button { padding:8px 10px; border:1px solid #ddd; border-radius:10px; font-size:13px; background:#fff;}
    input[type=text]{ min-width:260px; }
    button{ cursor:pointer; background:#111; color:#fff; border-color:#111;}
    button:disabled{ opacity:.7; cursor:not-allowed; }
    tr.clickable:hover{ background:#f7f7f7; cursor:pointer; }
    .muted{ color:var(--muted); font-size:12.5px; }
    .inline{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    summary{ cursor:pointer; }
    tr.vetted{ background:#eaffea !important; }
    .badge{ display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #ddd; background:#fff;}
    .badge-ok{ background:#e6ffed; border-color:#b3ffcc; color:#006622; }
    .badge-beb{ background:#ffe6e6; border-color:#ffb3b3; color:#b30000; }
    .note{ font-size:12.5px; color:#333; }
    .kv{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#f7f7f7; border:1px solid #eee; border-radius:10px; padding:8px; }
    /* custom suggest */
    #suggMenu{ position:absolute; z-index:9999; background:#fff; border:1px solid #e5e7eb; border-radius:8px; box-shadow:0 10px 24px rgba(0,0,0,.12); max-height:240px; overflow:auto; display:none; }
    #suggMenu .sugg-item{ padding:6px 10px; cursor:pointer; white-space:nowrap; overflow:hidden; text-overflow:ellipsis }
    #suggMenu .sugg-item:hover{ background:#f7f7f7 }
  </style>
</head>
<body>
  <h1>Orama X · Exoplanet Detector</h1>

  <div class="card">
    <h3>Live Fetch & Detect (select source)</h3>
    <div class="inline" style="margin-bottom:8px;">
      <label>Source</label>
      <select id="sourceSel">
        <option value="mast_spoc">MAST · SPOC (PDCSAP)</option>
        <option value="mast_qlp">MAST · QLP</option>
        <option value="url">External CSV/TXT URL</option>
      </select>

      <label>Mission</label>
      <select id="missionSel">
        <option value="auto">auto</option>
        <option value="TESS">TESS</option>
        <option value="Kepler">Kepler</option>
        <option value="K2">K2</option>
      </select>

      <label>k-peaks</label>
      <input type="number" id="kpeaks" value="3" min="1" max="5" style="width:70px"/>

      <label>Detrend</label>
      <select id="detrendSel">
        <option value="flatten" selected>flatten</option>
        <option value="none">none</option>
      </select>

      <label><input type="checkbox" id="qualityChk" checked/> quality mask</label>
      <label><input type="checkbox" id="outlierChk" checked/> remove outliers</label>

      <label>σ</label>
      <input type="number" id="sigmaVal" value="5" step="0.5" style="width:70px"/>

      <label><input type="checkbox" id="centroidChk"/> Centroid vetting (TESSCut)</label>
      <label><input type="checkbox" id="gaiaChk"/> Gaia neighbors</label>
    </div>

    <!-- Probability + Centroid thresholds -->
    <div class="inline" style="margin-bottom:8px;">
      <span class="badge">Planet threshold</span>
      <input type="range" id="thr" min="0.50" max="0.99" step="0.01" value="0.80" style="width:180px"/>
      <span class="muted">p · <b id="thrLabel">0.80</b></span>
      <span class="muted" id="vetCount"></span>

      <span class="badge">Centroid σ-thr</span>
      <input type="range" id="sigmaThr" min="1" max="10" step="0.5" value="3" style="width:160px"/>
      <span class="muted"><b id="sigmaThrLabel">3.0</b></span>

      <span class="badge">ρ-thr</span>
      <input type="range" id="rhoThr" min="0.00" max="0.50" step="0.01" value="0.15" style="width:160px"/>
      <span class="muted"><b id="rhoThrLabel">0.15</b></span>

      <span class="badge">Gaia radius ["]</span>
      <input type="range" id="neiRadius" min="20" max="120" step="5" value="60" style="width:160px"/>
      <span class="muted"><b id="neiRadiusLabel">60</b></span>
    </div>

    <div class="inline">
      <input type="text" id="ticInput" list="targetList" placeholder='TIC 307210830 (for MAST)' autocomplete="off" />
      
      <input type="text" id="urlInput" placeholder="https://.../lightcurve.csv (time,flux)" style="display:none; min-width:400px;" />
      <button id="runFetch">Fetch & Detect</button>
      <button id="exportCsv">Export CSV</button>
      <button id="exportVettedCsv" title="Export only candidates with P ≥ threshold">Export Vetted CSV</button>

      <span class="muted" id="status"></span>
    </div>

    <div class="inline" style="margin-top:8px;">
      <span class="badge">Fit method</span>
      <select id="fitMethod">
        <option value="batman">batman</option>
        <option value="trapezoid">trapezoid</option>
      </select>
      <span class="badge">bootstrap N</span>
      <input type="number" id="fitBoot" value="80" min="0" max="400" step="20" style="width:90px"/>
      <button id="fitBtn">Fit transit (selected)</button>

      <button id="pdfBtn" title="Create a PDF vetting report for the current target">Download PDF report</button>
      <span class="muted" id="fitStatus"></span>
    </div>
    <div id="fitBox" class="kv" style="margin-top:8px; display:none;"></div>
  </div>

  <details>
    <summary><b>Advanced: Upload custom light curve (TXT/CSV)</b></summary>
    <div class="card" style="margin-top:10px;">
      <h3>Upload TXT (2 columns: time, flux)</h3>
      <input type="file" id="file" accept=".txt,.csv"/>
      <button id="runUpload">Detect</button>
      <span class="muted" id="statusUp"></span>
    </div>
  </details>

  <div class="row">
    <div class="col card">
      <h3>Light Curve</h3>
      <div id="lc" style="height:380px;"></div>
    </div>
    <div class="col card">
      <h3>Phase-Folded (selected candidate)</h3>
      <div id="pf" style="height:340px;"></div>
      <div id="centroidBox" class="muted" style="margin-top:8px;"></div>
    </div>
  </div>

  <div class="card">
    <h3>Candidates <span class="muted">(green = vetted with P ≥ threshold; badge = centroid test)</span></h3>
    <table id="cands"><thead>
      <tr>
        <th>#</th><th>Period (d)</th><th>Duration (d)</th><th>Depth</th><th>Power</th><th>P(planet)</th>
        <th>SNR</th><th>ΔBIC</th><th>OddEven Δ (ppm)</th><th>Secondary?</th><th>Centroid</th>
      </tr>
    </thead><tbody></tbody></table>
  </div>

  <div class="card">
    <h3>Neighbors (Gaia DR3)</h3>
    <div id="neighborsPlot" style="height:320px;"></div>
    <div class="muted" id="neighborsInfo"></div>
    <table id="neighborsTbl" style="margin-top:8px;"><thead>
      <tr><th>sep ["]</th><th>Gmag</th><th>BPRP</th></tr>
    </thead><tbody></tbody></table>
  </div>

<script>
// ===== API base (δουλεύει για /detector ΚΑΙ /detector/index.html) =====
const API_BASE = '/detector/api';

// ---------- Helpers ----------
function parseTxt(text){
  const lines = text.trim().split(/\r?\n/);
  const T=[], F=[];
  for(const line of lines){
    const [a,b] = line.trim().split(/[ ,\t]+/);
    if(!a || !b) continue;
    const t = parseFloat(a), f = parseFloat(b);
    if(Number.isFinite(t) && Number.isFinite(f)){ T.push(t); F.push(f); }
  }
  return [T,F];
}
function phaseFold(time, flux, period, t0){
  const folded = time.map((t,i)=>({x:(((t - t0 + 1e6*period)%period)/period), y:flux[i]}));
  folded.sort((a,b)=>a.x-b.x);
  return folded;
}
function shadedShapes(intervals){
  if(!intervals) return [];
  return intervals.map(iv => ({type:'rect', xref:'x', yref:'paper', x0:iv[0], x1:iv[1], y0:0, y1:1, fillcolor:'rgba(0,0,0,0.08)', line:{width:0}}));
}
function renderLC(T, F, intervals){
  Plotly.newPlot('lc',[{x:T, y:F, mode:'markers', marker:{size:3}}], {margin:{t:10}, shapes: shadedShapes(intervals)});
}
function centroidBadge(cent, sigmaThr, rhoThr){
  if(!cent || !cent.available) return '';
  const sig = cent.sigma, rho = cent.rho_flux_centroid;
  const beb = (Number.isFinite(sig) && sig >= sigmaThr) && (!Number.isFinite(rho) || rho >= rhoThr);
  return beb ? '<span class="badge badge-beb">BEB</span>' : '<span class="badge badge-ok">OK</span>';
}
function renderCentroidInfo(cent, sigmaThr, rhoThr){
  const el = document.getElementById('centroidBox');
  if(!cent){ el.textContent = ''; return; }
  if(!cent.available){
    el.textContent = `Centroid: ${cent.reason || 'n/a'}`;
    return;
  }
  const parts = [];
  if (Number.isFinite(cent.dr_pix))  parts.push(`Δr = ${cent.dr_pix.toFixed(3)} px`);
  if (Number.isFinite(cent.sigma))   parts.push(`σ = ${cent.sigma.toFixed(2)} (thr ${sigmaThr.toFixed(2)})`);
  if (Number.isFinite(cent.rho_flux_centroid)) parts.push(`ρ = ${cent.rho_flux_centroid.toFixed(2)} (thr ${rhoThr.toFixed(2)})`);
  const txt = parts.join(', ');
  const badge = centroidBadge(cent, sigmaThr, rhoThr);
  el.innerHTML = `Centroid: ${txt} ${badge ? '  ' + badge : ''}`;
}
function renderNeighbors(nei){
  const info = document.getElementById('neighborsInfo');
  const tbl = document.querySelector('#neighborsTbl tbody');
  if(!nei || !nei.available){
    info.textContent = nei?.reason ? ('Gaia: ' + nei.reason) : 'Gaia: n/a';
    tbl.innerHTML=''; Plotly.purge('neighborsPlot'); return;
  }
  const items = nei.items || [];
  const rad = Number(nei.radius_arcsec || 60);
  info.textContent = `radius ${rad}"  ${items.length} sources (circle = 21" TESS pixel)`;
  tbl.innerHTML = '';
  items.slice(0,80).forEach(r=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${r.sep_arcsec.toFixed(1)}</td><td>${(r.Gmag??'').toString()}</td><td>${(Number.isFinite(r.BP_RP)?r.BP_RP.toFixed(2):'')}</td>`;
    tbl.appendChild(tr);
  });
  const x = items.map(r=>r.dx_arcsec), y = items.map(r=>r.dy_arcsec), s = items.map(r=>Math.max(6, 12 - 0.8*((r.Gmag??15)-10)));
  Plotly.newPlot('neighborsPlot',[
    {x:[0], y:[0], mode:'markers+text', text:['target'], textposition:'top center', marker:{size:10, symbol:'x'}},
    {x:x, y:y, mode:'markers', marker:{size:s}}
  ],{
    margin:{t:10}, xaxis:{title:'East ["]'}, yaxis:{title:'North ["]', scaleanchor:'x', scaleratio:1},
    shapes:[
      {type:'circle',xref:'x',yref:'y',x0:-21,y0:-21,x1:21,y1:21, line:{dash:'dot'}},
      {type:'circle',xref:'x',yref:'y',x0:-rad,y0:-rad,x1:rad,y1:rad, line:{dash:'solid'}}
    ]
  });
}

// ---------- State ----------
let lcTime=[], lcFlux=[], lastCands=[], currentTarget='(Uploaded TXT)';
let selectedIdx = 0;
let lastFit = null;
let lastNeighbors = null;
let lastPreproc = null;

// ---------- Threshold helpers ----------
function getThreshold(){ return Math.min(0.99, Math.max(0.5, Number(document.getElementById('thr').value || 0.8))); }
function setThrLabel(){ document.getElementById('thrLabel').textContent = getThreshold().toFixed(2); }
function getSigmaThr(){ return Number(document.getElementById('sigmaThr').value || 3.0); }
function getRhoThr(){   return Number(document.getElementById('rhoThr').value   || 0.15); }
function setCentroidThrLabels(){
  document.getElementById('sigmaThrLabel').textContent = getSigmaThr().toFixed(2);
  document.getElementById('rhoThrLabel').textContent = getRhoThr().toFixed(2);
}
function getNeighborsFlag(){ return document.getElementById('gaiaChk').checked; }
function getNeighborsRadius(){ return Number(document.getElementById('neiRadius').value || 60); }
function setNeighborsLabel(){ document.getElementById('neiRadiusLabel').textContent = getNeighborsRadius(); }
function updateVetCount(){
  const thr = getThreshold();
  const k = (lastCands||[]).filter(c=> (c?.probability ?? 0) >= thr).length;
  const n = (lastCands||[]).length;
  document.getElementById('vetCount').textContent = n ? ` vetted: ${k}/${n}` : '';
}

// ---------- Phase plot (with optional model overlay) ----------
function phaseFoldedTrace(T, F, cand){
  const folded = phaseFold(T, F, cand.period, cand.t0);
  return {x: folded.map(d=>d.x), y: folded.map(d=>d.y)};
}
function renderPF(T, F, cand){
  if(!cand) { Plotly.purge('pf'); return; }
  const pf = phaseFoldedTrace(T, F, cand);
  const traces = [{x: pf.x, y: pf.y, mode:'markers', marker:{size:3}, name:'data'}];
  if(lastFit && Math.abs(lastFit.params.period - cand.period) < 1e-6){
    const mf = lastFit.model_curve;
    const mfold = phaseFold(mf.time, mf.flux, lastFit.params.period, lastFit.params.t0);
    traces.push({x: mfold.map(d=>d.x), y: mfold.map(d=>d.y), mode:'lines', line:{width:2}, name:'model'});
  }
  Plotly.newPlot('pf', traces, {xaxis:{title:'Phase [0,1)'}, margin:{t:10}});
}

// ---------- Table rendering ----------
function renderTable(candidates){
  const tbody = document.querySelector('#cands tbody'); tbody.innerHTML='';
  const thr = getThreshold(), sThr = getSigmaThr(), rThr = getRhoThr();
  candidates.forEach((c, i)=>{
    const tr = document.createElement('tr'); tr.className = 'clickable'; tr.dataset.idx = i;
    if ((c?.probability ?? 0) >= thr) tr.classList.add('vetted');
    const snr  = (c.fit && Number.isFinite(c.fit.snr)) ? c.fit.snr.toFixed(1) : '';
    const dbic = (c.fit && Number.isFinite(c.fit.delta_bic)) ? c.fit.delta_bic.toFixed(1) : '';
    const badge = centroidBadge(c.centroid, sThr, rThr);
    tr.innerHTML = `<td>${i+1}</td><td>${c.period.toFixed(6)}</td><td>${c.duration.toFixed(6)}</td>
                    <td>${(+c.depth).toExponential(2)}</td><td>${c.power.toFixed(3)}</td>
                    <td class='prob'>${(100*c.probability).toFixed(1)}%</td>
                    <td>${snr}</td><td>${dbic}</td>
                    <td>${Math.round(c.vetting.odd_even_diff_ppm)}</td>
                    <td>${c.vetting.has_secondary_like ? 'Yes' : 'No'}</td>
                    <td>${badge}</td>`;
    tr.onclick = ()=> selectCandidate(i);
    tbody.appendChild(tr);
  });
  updateVetCount();
}
function selectCandidate(i){
  selectedIdx = i;
  const cand = lastCands[i];
  renderPF(lcTime, lcFlux, cand);
  renderLC(lcTime, lcFlux, cand.windows ? cand.windows.intervals : []);
  renderCentroidInfo(cand.centroid, getSigmaThr(), getRhoThr());
  document.getElementById('fitBox').style.display='none';
  lastFit = null;
}
function renderAll(T, F, candidates, neighbors){
  lcTime=T; lcFlux=F; lastCands=candidates||[]; selectedIdx=0;
  lastNeighbors = neighbors || null;
  renderLC(T,F, lastCands[0]?.windows?.intervals || []);
  renderPF(T,F, lastCands[0]);
  renderCentroidInfo(lastCands[0]?.centroid, getSigmaThr(), getRhoThr());
  renderTable(lastCands);
  renderNeighbors(neighbors);
}

// ---------- Source toggle ----------
function toggleInputs(){
  const src = document.getElementById('sourceSel').value;
  document.getElementById('ticInput').style.display = (src==='url')?'none':'inline-block';
  document.getElementById('urlInput').style.display = (src==='url')?'inline-block':'none';
}

// ---------- Fetch & Detect ----------
async function runFetch(){
  const status = document.getElementById('status');
  try{
    status.textContent = 'Fetching...';
    const source = document.getElementById('sourceSel').value;
    const mission = document.getElementById('missionSel').value;
    const target = document.getElementById('ticInput').value.trim();
    const url    = document.getElementById('urlInput').value.trim();

    const kpeaks = Number(document.getElementById('kpeaks').value || 3);
    const detrend = document.getElementById('detrendSel').value;
    const quality = document.getElementById('qualityChk').checked;
    const remove_outliers = document.getElementById('outlierChk').checked;
    const sigma = Number(document.getElementById('sigmaVal').value || 5);
    const centroid = document.getElementById('centroidChk').checked;

    const neighbors = document.getElementById('gaiaChk').checked;
    const neighbors_radius = Number(document.getElementById('neiRadius').value || 60);

    const body = JSON.stringify({ source, mission, target, url, kpeaks, detrend, quality, remove_outliers, sigma, centroid, neighbors, neighbors_radius });
    const res = await fetch(`${API_BASE}/fetch_detect`, { method:'POST', headers:{'Content-Type':'application/json'}, body });
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget = data.target || target || url;
    lastPreproc = data.preprocess || null;
    renderAll(data.time, data.flux, data.candidates, data.neighbors);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}

// ---------- Upload TXT ----------
async function runUpload(){
  const status = document.getElementById('statusUp');
  try{
    status.textContent = 'Running...';
    const file = document.getElementById('file').files[0];
    if(!file){ alert('Choose a .txt or .csv first'); status.textContent=''; return; }
    const txt = await file.text();
    const [T,F] = parseTxt(txt);
    const form = new FormData(); form.append('file', new Blob([txt], {type:'text/plain'}), 'lc.txt');
    const res = await fetch(`${API_BASE}/predict-file?kpeaks=3`, {method:'POST', body: form});
    const data = await res.json();
    if(data.error){ alert(data.error); status.textContent=''; return; }
    currentTarget='(Uploaded TXT)';
    lastPreproc = {source:'upload'};
    lastNeighbors = null;
    renderAll(T,F,data.candidates, null);
    status.textContent = 'Done';
  } catch(e){ status.textContent = 'Error'; console.error(e); }
}

// ---------- Export CSV ----------
function buildCsvRows(cands){
  const rows = [];
  rows.push(["target","idx","period_d","duration_d","depth","power","P_planet","SNR","delta_BIC","odd_even_ppm","secondary_ppm","has_secondary","midtimes_sample","centroid_dr_pix","centroid_sigma","centroid_rho","centroid_suspect_beb"]);
  cands.forEach((c,i)=>{
    const mids = (c.windows?.midtimes||[]).slice(0,5).join("|");
    const cent = c.centroid || {};
    rows.push([currentTarget, i+1, c.period, c.duration, c.depth, c.power, c.probability,
               (c.fit?.snr ?? ""), (c.fit?.delta_bic ?? ""),
               Math.round(c.vetting.odd_even_diff_ppm), Math.round(c.vetting.secondary_depth_ppm),
               c.vetting.has_secondary_like, mids,
               (cent.dr_pix ?? ""), (cent.sigma ?? ""), (cent.rho_flux_centroid ?? ""), (cent.suspect_beb ?? "")]);
  });
  return rows;
}
function exportCsv(rows, name){
  const csv = rows.map(r=>r.join(",")).join("\n");
  const a = document.createElement("a");
  a.href = URL.createObjectURL(new Blob([csv], {type:"text/csv"}));
  a.download = name; a.click();
}

// --- SUGGEST helpers (17B-friendly + robust) ---
function normalizeSuggestData(data){
  const raw = Array.isArray(data) ? data : (data?.items ?? data?.results ?? data?.suggestions ?? data?.data ?? []);
  return (raw || []).map(it => {
    if (typeof it === 'string') return { value: it, label: it };
    const value = it.value ?? it.id ?? it.tic ?? it.name ?? it.target ?? '';
    const label = it.label ?? it.display ?? (it.tic ? `TIC ${it.tic}` : (it.name ?? value));
    return { value, label };
  });
}
function ensureSuggestMenu(){
  let m = document.getElementById('suggMenu');
  if(!m){ m = document.createElement('div'); m.id='suggMenu'; document.body.appendChild(m); }
  return m;
}
function placeSuggestMenu(input){
  const r=input.getBoundingClientRect();
  const m=ensureSuggestMenu();
  m.style.left=(window.scrollX + r.left)+ 'px';
  m.style.top =(window.scrollY + r.bottom + 4)+ 'px';
  m.style.width = r.width+'px';
}
function showSuggest(list, input){
  const m=ensureSuggestMenu();
  placeSuggestMenu(input);
  m.innerHTML = list.map((s,i)=>`<div class="sugg-item" data-i="${i}">${(s.label||s.value||'').toString()}</div>`).join('');
  Array.from(m.children).forEach(el=>{
    el.addEventListener('mousedown', (e)=>{
      const i = +e.currentTarget.getAttribute('data-i');
      applySuggestion(list[i], input);
      hideSuggest();
      e.preventDefault();
    });
  });
  m.style.display='block';
}
function hideSuggest(){ const m=document.getElementById('suggMenu'); if(m) m.style.display='none'; }
function applySuggestion(s, input){ if(!s) return; input.value = s.value || s.label || ''; input.dispatchEvent(new Event('change', {bubbles:true})); }

// ---------- Autocomplete (17B semantics, αλλά με απόλυτο API + custom dropdown) ----------
function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }
const updateSuggest = debounce(async ()=>{
  const input = document.getElementById('tic') || document.getElementById('ticInput');
  if (!input) return;

  const raw = (input.value || '').trim();
  if (!raw) { hideSuggest(); return; }

  // Αν είναι μόνο ψηφία ή "TIC <digits>" => contains mode
  const onlyDigits = /^\d{2,}$/.test(raw);
  const ticDigits  = /^TIC\s*\d{2,}$/i.test(raw);
  let q = raw;
  if (onlyDigits) q = `TIC ${raw}`;

  const mission = document.getElementById('missionSel')?.value || 'auto';
  const domParam = (mission === 'TESS') ? '&domain=TESS' : (mission === 'Kepler' ? '&domain=Kepler' : '');
  const containsParam = (onlyDigits || ticDigits) ? '&contains=1' : '';

  try{
    const r = await fetch(`${API_BASE}/suggest?q=${encodeURIComponent(q)}${domParam}&limit=10${containsParam}`,
                          { headers:{ 'Accept':'application/json' }});
    let list = [];
    if (r.ok) list = normalizeSuggestData(await r.json());
    if (list.length) showSuggest(list, input); else hideSuggest();
  }catch {
    hideSuggest();
  }
}, 220);


// ---------- Transit Fit ----------
async function runFit(){
  const fitStatus = document.getElementById('fitStatus');
  const fitBox = document.getElementById('fitBox');
  try{
    if(!lastCands.length){ alert('Run detect first'); return; }
    const cand = lastCands[selectedIdx];
    if(!cand){ alert('Select a candidate'); return; }
    fitStatus.textContent = 'Fitting...';
    const method = document.getElementById('fitMethod').value;
    const bootstrap = Number(document.getElementById('fitBoot').value || 80);
    const body = JSON.stringify({ time: lcTime, flux: lcFlux, candidate: { period: cand.period, t0: cand.t0, duration: cand.duration }, method, bootstrap });
    const res = await fetch(`${API_BASE}/fit_transit`, { method:'POST', headers:{'Content-Type':'application/json'}, body });
    const data = await res.json();
    if(data.error){ alert(data.error); fitStatus.textContent=''; return; }
    lastFit = { params: data.params, model_curve: data.model_curve };
    renderPF(lcTime, lcFlux, cand);
    const p = data.params || {}; const u = data.uncertainties || {};
    function fmt(v, s){ if(v==null || !isFinite(v)) return ''; return (s!=null && isFinite(s)) ? `${v.toFixed(4)}  ${s.toFixed(4)}` : v.toFixed(4); }
    fitBox.innerHTML = `
      <div><b>Method:</b> ${data.method}${data.note?` (${data.note})`:''}</div>
      <div><b>Rp/R:</b> ${fmt(p.rp_rs, u.rp_rs)}  <b>b:</b> ${fmt(p.b, u.b)}  <b>a/R:</b> ${fmt(p.a_rs, u.a_rs)}</div>
      <div class="muted">P=${p.period?.toFixed? p.period.toFixed(6):p.period} d, t0=${p.t0?.toFixed? p.t0.toFixed(6):p.t0}</div>
    `;
    fitBox.style.display='block';
    fitStatus.textContent = 'Done';
  }catch(e){ console.error(e); fitStatus.textContent = 'Error'; }
}

// ---------- PDF report ----------
async function runPdf(){
  try{
    if(!lastCands.length){ alert('Run detect first'); return; }
    const cand = lastCands[selectedIdx];
    const meta = { target: currentTarget, source: document.getElementById('sourceSel').value, mission: document.getElementById('missionSel').value };
    const payload = {
      meta,
      preprocess: lastPreproc || {},
      time: lcTime, flux: lcFlux,
      candidate: cand,
      neighbors: lastNeighbors || {},
      fit_method: document.getElementById('fitMethod').value
    };
    const res = await fetch(`${API_BASE}/report_pdf`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
    if(!res.ok){
      const j = await res.json().catch(()=>({error:"unknown"}));
      alert(j.error || "report failed"); return;
    }
    const blob = await res.blob();
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `Oramax_Vetting_${(currentTarget||'target').toString().replace(/\s+/g,'_')}.pdf`;
    a.click();
  }catch(e){ console.error(e); alert("report failed"); }
}

// ---------- Wire-up ----------
document.addEventListener('DOMContentLoaded', ()=>{
  setThrLabel(); setCentroidThrLabels(); setNeighborsLabel();
  toggleInputs();

  document.getElementById('sourceSel').addEventListener('change', toggleInputs);
  const ticInp = document.getElementById('ticInput');
  ticInp.removeAttribute('list');         // απενεργοποιεί native datalist
  ticInp.addEventListener('input', updateSuggest);
  ticInp.addEventListener('focus', ()=>{ if((ticInp.value||'').trim().length>=3) updateSuggest(); });
  ticInp.addEventListener('change', ()=>{ hideSuggest(); });

  document.getElementById('runFetch').addEventListener('click', runFetch);
  document.getElementById('runUpload').addEventListener('click', runUpload);

  document.getElementById('exportCsv').addEventListener('click', ()=>{
    if(!lastCands.length){ alert("Run Detect first."); return; }
    exportCsv(buildCsvRows(lastCands), `oramax_candidates_${(currentTarget||'target').toString().replace(/\s+/g,'_')}.csv`);
  });
  document.getElementById('exportVettedCsv').addEventListener('click', ()=>{
    if(!lastCands.length){ alert("Run Detect first."); return; }
    const thr = getThreshold();
    const vetted = lastCands.filter(c => (c?.probability ?? 0) >= thr);
    if(!vetted.length){ alert(`No candidates with P ≥ ${thr.toFixed(2)}`); return; }
    const rows = buildCsvRows(vetted);
    rows.unshift(["threshold", thr]);
    exportCsv(rows, `oramax_vetted_${(currentTarget||'target').toString().replace(/\s+/g,'_')}_p${thr.toFixed(2)}.csv`);
  });

  document.getElementById('thr').addEventListener('input', ()=>{ setThrLabel(); renderTable(lastCands||[]); });
  document.getElementById('sigmaThr').addEventListener('input', ()=>{ setCentroidThrLabels(); renderTable(lastCands||[]); renderCentroidInfo(lastCands[selectedIdx]?.centroid, getSigmaThr(), getRhoThr()); });
  document.getElementById('rhoThr').addEventListener('input', ()=>{ setCentroidThrLabels(); renderTable(lastCands||[]); renderCentroidInfo(lastCands[selectedIdx]?.centroid, getSigmaThr(), getRhoThr()); });
  document.getElementById('neiRadius').addEventListener('input', ()=>{ setNeighborsLabel(); });

  document.getElementById('fitBtn').addEventListener('click', runFit);
  document.getElementById('pdfBtn').addEventListener('click', runPdf);
});
</script>
</body>
</html>


